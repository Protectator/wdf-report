%%%%%%%%%%%%%%%%%%%%%%%%%%
%                          %
% ----- INTRODUCTION ----- %
%                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Technologies}

	\subsection{Introduction}

		Dans cette section se trouveront des schémas représentant des algorithmes. Les étapes de ceux-ci peuvent être exécutés à trois moments différents, indiqué sur leurs schémas :
		\begin{description}
			\item[Offline] Les étapes effectuées "offline" recquièrent une intervention de l'administrateur. C'est à lui de décider quand ces traitements doivent intervenir car ils ne peuvent pas être effectuées pendant que le serveur fonctionne.
			\item[Serveur] Les étapes effectuées sur le "serveur" sont calculées pendant que le serveur est en ligne, typiquement lorsque celui-ci reçoit une requête.
			\item[Client] Les étapes s'effectuant sur le "client" sont calculées dans le navigateur de l'utilisateur actuel.
		\end{description}

	\subsection{Serveur}

		Le serveur est développé en Python3.6, et utilise le framework Flask. Flask permet de définir rapidement le comportement d'un serveur web basique en mappant des fonctions à des endpoints de l'API.

		Par exemple, à l'aide d'une combinaison de décorateurs fournis par Flask et crées par nous-même, nous pouvons très facilement spécifier le comportement d'une méthode. La figure~\ref{i-code-server} montre le peu de code nécessaire pour définir l'endpoint de vérification de la connexion de l'utilisateur.

		\begin{figure}[!h]
			\centering
			\begin{lstlisting}[language=python]
@app.route("/api/connectionState", methods=['GET'])
@userConnected
@apiMethod
def connectionState(wdfId):
    return jsonify({'success': "Connected", "wdfId": wdfId})\end{lstlisting}
			\caption{Code de la méthode de vérification de connexion}
			\label{i-code-server}
		\end{figure}

		Naturellement, la plupart des autres méthodes nécessitent un accès à la base de données MySQL et donc du code plus conséquent.

		Ici, Flask n'écoute pas directement sur les ports concernés. Le programme entier est accessible derrière un serveur Apache pour des questions de sécurité : la communication entre l'extension, l'interface et le serveur se fait en HTTPS, grâce à la gestion de SSL par Apache, et un certificat obtenu à l'aide de Let's Encrypt.


	\subsection{Client}

		L'interface est développée en JavaScript et TypeScript en utilisant le framework Vue.js. Comme plusieurs de ses autres équivalents, Vue.js permet d'organiser le code en composants réutilisables. Le but étant de développer une one-page app pour des raisons de réactivité de l'interface. Un des avantages de ce type de framework est donc la possibilité de configurer un router.

		\begin{wrapfigure}{r}{3cm}
			\includegraphics[width=2.9cm]{images/design/loading_spinner}
			\caption{Chargement des données}\label{i-loading}
		\end{wrapfigure} 

		Ceci permet à l'utilisateur d'avoir l'impression de naviguer entre plusieurs pages distinctes, alors que tout le processus prend place dans le framework lui-même, qui se charge de changer le contenu affiché sans nécessiter de requête supplémentaire au serveur.

		Au lancement de la page, l'interface entière est donc chargée sur le navigateur, et l'ensemble des données de l'utilisateur est demandée au serveur. La figure~\ref{i-loading} montre le spinner affiché à l'utilisateur pendant le chargement.

%
%
% WORDCLOUD
%
%

\section{Wordcloud}

	\subsection{Concept}
git status
		Le wordcloud montre à l'utilisateur la liste des mots qu'il lit le plus fréquemment. Le visualisation est un amassage de mots de différentes tailles, placés d'une manière aléatoire sur un rectangle. Les mots les plus lus ont une taille plus grande afin d'attirer l'attention de l'utilisateur.

		Cette visualisation cherche à donner très rapidement une impression générale des thèmes que l'utilisateur parcourt lors de sa navigation.

		\begin{figure}[!h]
			\centering
			\subfloat[Maquette initiale de la vue]{\includegraphics[width=0.33\textwidth,valign=t]{images/design/pages/wordcloud_mockup}}
			\subfloat[Exemple de résultat final]{\includegraphics[width=0.66\textwidth,valign=t]{images/design/pages/wordcloud_final}}
			\caption{Maquette initiale et résultat final de la vue Wordcloud}
			\label{wordcloud_images}
		\end{figure}

		La figure~\ref{wordcloud_images} montre la différence entre la vue imaginée initialement et le résultat final.

	\subsection{Données}

		Les données source servant à constituer cette visualisation sont :
		\begin{description}
			\item[Temps de visualisation] : Temps de visualisation total de chaque page. Ces données sont stockées dans la table \texttt{pagewatch} (figure \ref{table-content}).
			\item[Poids TF-IDF] : Poids final selon l'algorithme TF-IDF de chaque mot. Ces données sont stockées dans la table \texttt{computed\_tfidf} (figure \ref{table-computed-tfidf}).
		\end{description}

	\subsection{Traitement}

		Afin de déterminer quels sont les mots affichés ainsi que leur taille sur la visualisation, on assigne un "poids" à chaque mot.

		La figure~\ref{wordcloud_algo} illustre le fonctionnement de l'algorithme utilisé :
		\begin{description}
			\item[A] On calcule le poids de chaque mot dans chaque document en effectuant la méthode de TF-IDF. Le poids TF-IDF de chaque mot est stocké dans la base de données, mais n'est pas constamment rafraîchi. L'opération de calcul des poids TF-IDF est une opération ponctuelle qui doit être lancée sur l'entièreté de la base de données par l'administrateur. Cette opération ne nécessite cependant pas de redémarrage du serveur.

			\item[B] On effectue la somme du temps que l'utilisateur a passé à regarder chaque page visitée. Cette opération est effectuée sur le serveur et est calculée en direct par une commande MySQL, elle est donc constamment à jour. L'interface obtient ce résultat en appelant l'endpoint \texttt{/api/mostWatchedSites} du serveur. Le résultat de cet appel est une liste de l'ensemble des pages web visitées, comprenant entre autres pour chaque page : 
			\begin{itemize}
				\item Son URL
				\item Le temps total de visite, en secondes
				\item Une liste des mots les plus significatifs selon TF-IDF ainsi que leur poids TF-IDF (normalisé entre 0 et 1)
			\end{itemize}
			
			On initialise un dictionnaire qui va contenir le poids de chaque mot.

			\item[C] Pour chaque page web, on multiplie l'indice TF-IDF de chaque mot avec le temps de visualisation de la page. On additionne ce résultat au poids actuel du mot.
			
			Une fois tous les mots de toutes les pages web traités, nous sommes en possession d'un dictionnaire nous indiquant le poids final de chaque mot. Ce poids est donc égal à la somme de l'indice TF-IDF du mot sur chaque page multiplié par le temps de visite sur cette page.
			
			\item[D] On trie les mots par leur poids final, et on ne conserve que les 200 premiers. Il s'agira des 200 mots présents sur le wordcloud.
			
			Pour chacun des 200 mots, leur taille sur le Wordcloud est égale à leur poids final.
		\end{description}

		\begin{figure}[!h]
			\centering
			\includegraphics[height=1\textwidth]{images/design/pages/wordcloud_algo}
			\caption{Algorithme utilisé pour le Wordcloud}
			\label{wordcloud_algo}
		\end{figure}

	\subsection{Visualisation}

			La page va s'occuper d'agréger les résultats reçus du serveur. Ensuite, elle utilise les librairies \texttt{d3-cloud} ainsi que \texttt{d3} pour générer la visualisation du Wordcloud.

\clearpage

%
%
% TOPICS LIST
%
%

\section{Topics List}\label{topicslist}

	\subsection{Concept}

		Le "Topics List" cherche à rassembler les mots en thèmes, et montre d'une manière plus synthétique les thèmes estimés que l'utilisateur parcourt fréquamment. À chaque thème est lié un ou plusieurs mots, qui reprèsentent le thème d'une manière générale. Chaque cercle du graphe représente soit un thème, soit un mot.

		Le but de cette visualisation est de montrer que nous pouvons déduire des thèmes et ainsi montrer un traitement plus fin des intérêts de l'utilisateur, que simplement additionner une liste de mots. Dans le marketing, les thèmes découverts pourraient être utilisés pour labelliser les utilisateurs à qui faire apparaître une publicité.

		\begin{figure}[!h]
			\centering
			\subfloat[Maquette initiale de la vue]{\includegraphics[width=0.33\textwidth,valign=t]{images/design/pages/topics_mockup}}
			\subfloat[Exemple de résultat final]{\includegraphics[width=0.66\textwidth,valign=t]{images/design/pages/topics_final}}
			\caption{Maquette initiale et résultat final de la vue Wordcloud}
			\label{topics_images}
		\end{figure}

		La figure~\ref{topics_images} montre la différence entre la vue imaginée et le résultat final. On note ici que le principe même de la vue ainsi que son nom sont différents qu'initialement.

	\subsection{Données}

		Les données source servant à constituer cette visualisation sont :
		\begin{description}
			\item[Temps de visualisation] : Temps de visualisation total de chaque page. Ces données sont stockées dans la table \texttt{pagewatch} (figure \ref{table-content}).
			\item[Topics LDA] : Liste des topics générés par le modèle LDA. Ces données sont stockées dans la table \texttt{lda\_topics} (figure \ref{table-lda-topics}).
			\item[Topics par page] : Liste pré-caluclée des topics trouvés pour chaque page. Ces données sont stockées dans la table \texttt{current\_url\_topics} (figure \ref{table-current-url-topics}).
			\item[Intérêts utilisateur] : Liste des intérêts renseignés par l'utilisateur. Ces données sont stockées dans la table \texttt{user\_interests} (figure \ref{table-user-interests}).
			\item[Correspondances topic-intrêt] : Liste des correspondances entre topic et intérêt renseignés par l'utilisateur. Ces données sont stockées dans la table \texttt{current\_user\_tags} (figure \ref{table-current-user-tags}).
		\end{description}

	\subsection{Traitement}

		Afin de déterminer quels sont les topics affichés ainsi que leur intérêt estimé, on assigne un "score" à chaque topic pour l'utilisateur.

		L'algorithme suivant, illustré par la figure~\ref{topics_algo}, est appliqué aux données sources :
		\begin{description}
			\item[A] On entraîne un modèle LDA avec un nombre défini de topics (typiquement 100) sur le contenu de l'ensemble des pages web, une page web représentant un document.

			Le modèle LDA est enregistré sur le disque local, et les résultats tirés de celui-ci, comme une la représentation en 5 mots de chaque topic, est maintenant stockés dans la base de données. Tout ceci n'est donc pas constamment rafraîchi. L'opération d'entraînement du modèle LDA est une opération ponctuelle qui doit être lancée sur l'entièreté de la base de données par l'administrateur. Cette opération nécessite le redémarrage du serveur, car de nombreuses mesures temporaires sont touchées.

			\item[B] Pour chaque page enregistrée, on demande au modèle LDA quels sont les 5 topics les plus probables avec leur score de probabilité. Ces informations sont également enregistrées dans la base de données. Jusqu'ici, toutes ces opérations sont donc déjà calculées et se font avant le lancement du serveur. Elles ne sont pas mises à jour en temps réel.
			
			\item[C] On effectue la somme du temps que l'utilisateur a passé à regarder chaque page visitée. Cette opération est effectuée sur le serveur et est calculée en direct par une commande MySQL, elle est donc constamment à jour. L'interface obtient ce résultat en appelant l'endpoint \texttt{/api/mostWatchedSites} du serveur. Le résultat de cet appel est une liste de l'ensemble des pages web visitées, comprenant entre autres pour chaque page : 
			\begin{itemize}
				\item Son URL
				\item Le temps total de visite, en secondes
				\item Une liste des topics les plus significatifs selon le modèle LDA ainsi que leur probabilité
			\end{itemize}

			\item[D] L'endpoint \texttt{/api/allTopics} renvoie la liste des topics générés par LDA ainsi que leur numéro d'identifiant.

			\item[E] L'endpoint \texttt{/api/getCurrentTags} renvoie la liste des associations que l'utilisateur a crée pour le modèle LDA courant. Il s'agit d'une liste de couples topicId $\longleftrightarrow$ interestId.

			\item[F] L'endpoint \texttt{/api/interestsList} renvoie la liste des 101 intérêts globaux à tous les utilisateurs.

			\item[G] On initialise un dictionnaire qui va contenir le score de chaque topic.
			
			Pour chaque page web, on multiplie la probabilité de chaque topic LDA avec le temps de visualisation de la page. On additionne ce résultat au score actuel du topic.
			
			Une fois tous les topics de toutes les pages web traités, nous sommes en possession d'un dictionnaire nous indiquant le score final de chaque topics. Ce score est donc égal à la somme de la probabilité du topic sur chaque page multiplié par le temps de visite sur cette page.
			
			\item[H] On trie les topics par leur score final, et on ne conserve que les 20 premiers. Il s'agira des 20 topics présents sur la page.

			\item[I] On sélectionne les centres d'intérêt de l'utilisateur, ainsi que les associations qu'il a déjà crée pour le modèle LDA actuel. On ajoute les associations aux topics de l'interface.
		\end{description}

		\begin{figure}[!h]
			\centering
			\includegraphics[height=1.35\textwidth]{images/design/pages/topics_algo}
			\caption{Algorithme utilisé pour le Topics List}
			\label{topics_algo}
		\end{figure}

	\subsection{Visualisation}

			La page va s'occuper d'agréger les résultats reçus du serveur. La liste est ensuite générée sous forme d'un tableau HTML en passant par un composant Vue personnalisé. Les barres d'intérêt sont des éléments \texttt{progressbar} venant de Bootstrap.

\clearpage

%
%
% MOST WATCHED
%
%

\section{Most Watched}

	\subsection{Concept}

		Les pages "Most Watched" et "Most Visited" montrent deux informations, mais sous une forme semblable. Ces pages affichent quelles pages web et les domaines que l'utilisateur a visité le plus. Plus précisément, "Most Watched" s'intéresse au temps réel passé à lire chaque page, et "Most Visited" s'intéresse au nombre d'ouvertures de l'URL.

		Le but est ici de faire prendre conscience à l'utilisateur qu'il est possible de se rendre compte de son activité une page web, et un grand nombre d'ouvertures d'un lien ne veut pas forcément dire un grand intérêt pour cette page.

		On profite également de cet espace pour afficher les mots relatifs aux pages web qui ont le plus d'intérêt, afin de montrer qu'il est possible de déterminer quels sont les mots importants d'une page web simplement en la comparant au contenu des autres pages.

		La figure~\ref{mostwatched_images} montre la différence entre la vue imaginée et le résultat final.

		\begin{figure}[!h]
			\centering
			\subfloat[Maquette initiale de la vue]{\includegraphics[width=0.33\textwidth,valign=t]{images/design/pages/mostwatched_mockup}}
			\subfloat[Exemple de résultat final]{\includegraphics[width=0.66\textwidth,valign=t]{images/design/pages/mostwatched_final}}
			\caption{Maquette initiale et résultat final de la vue Most Watched}
			\label{mostwatched_images}
		\end{figure}

		Comme certaines pages web demandent une connexion pour être visualisées, par exemple la page d'accueil de \url{https://www.facebook.com}, nous omettons volontairement une liste de pages web dans ce classement, car nous n'avons pas d'informations intéressante sur leur contenu à montrer. En effet, nous ne téléchargeons volontairement pas de copie de la page vue par l'utilisateur pour des questions de protection de données privées. Notre serveur télécharge la version publique de l'URL visitée par l'utilisateur pour en déterminer son contenu. Ainsi, il ne fait pas sens d'analyser le contenu des pages générées dynamiquement par l'utilisateur.

	\subsection{Données}

		Les données source servant à constituer cette visualisation sont :
		\begin{description}
			\item[Temps de visualisation] : Temps de visualisation total de chaque page. Ces données sont stockées dans la table \texttt{pagewatch} (figure \ref{table-content}).
			\item[Nombre de visites] : Nombre total d'ouvertures de chaque URL. Ces données sont stockées dans la table \texttt{pageviews} (figure \ref{table-pageviews}).
			\item[Poids TF-IDF] : Poids final selon l'algorithme TF-IDF de chaque mot. Ces données sont stockées dans la table \texttt{computed\_tfidf} (figure \ref{table-computed-tfidf}).
		\end{description}

	\subsection{Traitement}

		Afin de déterminer quels sont les pages et les domaines affichés, on demande au serveur la liste triée des URLs les plus regardées et ouvertes.

		L'algorithme suivant, illustré par la figure~\ref{mostwatched_algo}, est appliqué aux données sources :
		\begin{description}
			\item[A] On calcule le poids de chaque mot dans chaque document en effectuant la méthode de TF-IDF. Le poids TF-IDF de chaque mot est stocké dans la base de données, mais n'est pas constamment rafraîchi. L'opération de calcul des poids TF-IDF est une opération ponctuelle qui doit être lancée sur l'entièreté de la base de données par l'administrateur. Cette opération ne nécessite cependant pas de redémarrage du serveur.

			\item[B] On effectue la somme du temps que l'utilisateur a passé à regarder chaque page visitée. Cette opération est effectuée sur le serveur et est calculée en direct par une commande MySQL, elle est donc constamment à jour. L'interface obtient ce résultat en appelant l'endpoint \texttt{/api/mostWatchedSites} du serveur. Le résultat de cet appel est une liste de l'ensemble des pages web regardées, comprenant entre autres pour chaque page : 
			\begin{itemize}
				\item Son URL
				\item Le temps total de visite, en secondes
				\item Une liste des mots les plus significatifs selon TF-IDF ainsi que leur poids TF-IDF (normalisé entre 0 et 1)
			\end{itemize}

			\item[C] On effectue la somme du nombre d'ouvertures de chaque page visitée. Cette opération est effectuée sur le serveur, et l'interface obtient ce résultat en appelant l'endpoint \texttt{/api/mostVisitedSites} du serveur. Le résultat de cet appel est une liste de l'ensemble des pages web visitées, comprenant entre autres pour chaque page : 
			\begin{itemize}
				\item Son URL
				\item Le nombre total d'ouvertures
				\item Une liste des mots les plus significatifs selon TF-IDF ainsi que leur poids TF-IDF (normalisé entre 0 et 1)
			\end{itemize}
			
			\item[D] Une fois la liste des pages les plus regardées obtenue, on ne conserve que les 10 premières d'entre-elles pour des raisons visuelles. Ces 10 premières pages sont alors affichées.

			\item[E] Ensuite, on cherche à agréger le temps de visualisation par domaine plutôt que par page, afin d'avoir une vue d'ensemble. On additionne donc le temps passé à regarder les pages d'un même domaine.

			\item[F] On trie la nouvelle liste de domaines crée par leur temps total de visualisation, et on ne garde également que les 10 premiers d'entre-eux pour les afficher.

			\item[G] On s'occupe ensuite du traitement du nombre d'ouvertures de chaque page. On ne conserve également que les 10 plus ouvertes d'entre-elles pour des raisons visuelles, elles sont alors affichées dans la liste.

			\item[H] Ensuite, on agrèger le nombre d'ouvertures par domaine plutôt que par page, afin d'avoir une vue d'ensemble. On additionne donc le temps passé à regarder les pages d'un même domaine.

			\item[I] On trie la nouvelle liste de domaines crée par leur temps total de visualisation, et on ne garde également que les 10 premiers d'entre-eux pour les afficher.
		\end{description}

		\begin{figure}[!h]
			\centering
			\includegraphics[height=0.8\textwidth]{images/design/pages/mostwatched_algo}
			\caption{Algorithme utilisé pour les pages "Most Watched" et "Most Visited"}
			\label{mostwatched_algo}
		\end{figure}

	\subsection{Visualisation}

		La page va s'occuper d'agréger les résultats reçus du serveur. Chaque liste est ensuite générée sous forme d'un tableau HTML en passant par un composant Vue personnalisé. Les barres relatives à la quantité exprimée par chaque tableau ajoute un élément de comparaison visuel, et sont des éléments \texttt{progressbar} venant de Bootstrap.

\clearpage

%
%
% HISTORY
%
%

\section{History}

	\subsection{Concept}

		La page "History" permet de montrer à l'utilisateur la variation de ses habitudes au cours du temps durant lequel il a utilisé l'extension. Deux graphiques sont présents sur cette page : Le premier montre la tendence à visiter des pages relatées à certains topics, et l'autre montre la tendence dans la visite de pages contenant certains mots particuliers. Le but est ici de détecter d'éventuels intérêts passagers dans le temps.

		La figure~\ref{history_images} montre la différence entre la vue imaginée et le résultat final.

		\begin{figure}[!h]
			\centering
			\subfloat[Maquette initiale de la vue]{\includegraphics[width=0.3\textwidth,valign=t]{images/design/pages/history_mockup}}
			\subfloat[Exemple de résultat final]{\includegraphics[width=0.7\textwidth,valign=t]{images/design/pages/history_final}}
			\caption{Maquette initiale et résultat final de la vue History}
			\label{history_images}
		\end{figure}

	\subsection{Données}

		Les données source servant à constituer cette visualisation sont :
		\begin{description}
			\item[Temps de visualisation] : Temps de visualisation total de chaque page. Ces données sont stockées dans la table \texttt{pagewatch} (figure \ref{table-content}).
			\item[Historique de visualisation] : Temps passé par jour sur chaque URL. Les données non agrégées proviennent de la table \texttt{pageviews} (figure \ref{table-pagewatch}).
			\item[Poids TF-IDF] : Poids final selon l'algorithme TF-IDF de chaque mot. Ces données sont stockées dans la table \texttt{computed\_tfidf} (figure \ref{table-computed-tfidf}).
			\item[Topics LDA] : Liste des topics générés par le modèle LDA. Ces données sont stockées dans la table \texttt{lda\_topics} (figure \ref{table-lda-topics}).
		\end{description}

	\subsection{Traitement}

		Afin de déterminer quels sont les topics et les mots cumulant le plus d'intérêt, il est nécessaire de disposer de plusieurs sources de données et de les assembler afin d'arriver au résultat voulu. Ceci se fait en plusieurs étapes, distribuées entre le serveur et client.

		L'algorithme suivant, illustré par la figure~\ref{history_algo}, est appliqué aux données sources :
		\begin{description}
			\item[A] On calcule le poids de chaque mot dans chaque document en effectuant la méthode de TF-IDF.

			\item[B] On entraîne un modèle LDA avec un nombre défini de topics (typiquement 100) sur le contenu de l'ensemble des pages web, une page web représentant un document.
			
			Une fois le modèle LDA entraîné, on lui demande la liste des 100 topics générés par leur représentation en 5 mots. Cette liste de topics est enregistrée dans la base de données.

			\item[C] Pour chaque page enregistrée, on demande au modèle LDA quels sont les 5 topics les plus probables avec leur score de probabilité. Ces informations sont également enregistrées dans la base de données. Jusqu'ici, toutes ces opérations sont donc déjà calculées et se font avant le lancement du serveur. Elles ne sont pas mises à jour en temps réel.

			\item[D] On demande à la base de données de grouper le temps de visionnage (en secondes) en une somme par jour et par URL différente. Ceci se fait au travers d'une commande MySQL et est calculé en temps réel, et s'occupe également d'"arrondir" chaque date de visualisation d'une page à la journée (au lieu de la seconde près, qui est la granularité utilisée dans la base de données).

			\item[E] Le résultat de l'étape précédente est disponible via l'endpoint\\
			\texttt{/api/historySites}.

			\item[F] On effectue la somme du temps que l'utilisateur a passé à regarder chaque page visitée. L'interface obtient ce résultat en appelant l'endpoint\\
			\texttt{/api/mostWatchedSites} du serveur. Le résultat de cet appel est une liste de l'ensemble des pages web regardées, comprenant entre autres une liste des mots les plus significatifs selon TF-IDF ainsi que leur poids TF-IDF (normalisé entre 0 et 1) pour chaque page.
			
			\item[G] L'endpoint \texttt{/api/allTopics} renvoie la liste des topics générés par LDA ainsi que leur numéro d'identifiant.

			\item[H] On cherche à savoir quels sont les mots où lesquels l'utilisateur a montré le plus d'intérêt afin de les afficher sur le graphe. Pour ceci, on multiplie la valeur TF-IDF de chaque mot par le temps passé à visualiser la page. La somme de ce calcul sur toutes les pages va nous donner l'"intérêt" final de l'utilisateur pour un mot particulier. On ne gardera ici que les 8 mots avec le plus grand intérêt estimé.

			\item[I] Finalement, pour chacun des 8 mots retenus, on affiche leur intérêt journalier sur le deuxième graphique, "Words history".

			\item[J] On cherche à savoir quels sont les topics où lesquels l'utilisateur a montré le plus d'intérêt afin de les afficher sur le graphe.

			Voici ce que l'on effectue sur chaque page : Pour chaque topic où sa valeur selon le modèle LDA sur cette page est au-dessus de 0.1, on estie que la page parle de ce topic et on compte le temps passé à visualiser la page dans la valeur de ce topic pour la journée.

			Finalement, on somme le temps passé sur chaque "topic". Le résultat de ce calcul sur toutes les pages va nous donner l'"intérêt" final de l'utilisateur pour un topic particulier. On ne gardera ici que les 8 topics avec le plus grand intérêt estimé.

			\item[K] Finalement, pour chacun des 8 topics retenus, on affiche leur intérêt journalier (qui est la même somme que précédamment, mais agrégée par jour au lieu de toute la période) sur le premier graphique, "Topics history".
		\end{description}

		\begin{figure}[!h]
			\centering
			\includegraphics[height=1.15\textwidth]{images/design/pages/history_algo}
			\caption{Algorithme utilisé pour les graphiques de la page "History"}
			\label{history_algo}
		\end{figure}

	\subsection{Visualisation}

		Les données sont finalement transformées dans un format compatible et passées à une instance configurée de la librairie HighCharts, qui génère la visualisation du graphique sur la page.

\clearpage

%
%
% TRACKERS
%
%

\section{Trackers}

	\subsection{Concept}

		La vue "Trackers" comporte deux pages liées à une seule source de données. Le but est de montrer à l'utilisateur que lorsqu'une page web est visitée, des informations peuvent tout de même être transmises à d'autres domaines.

		La première vue de l'interface, "Most Sending", montre quels sont les domaines qui contactent beacoup des domaines différents. Il peut ainsi voir sur cette vue quels sont les serveurs qui sont contactés lorsqu'il accède à une page web.

		L'inverse est possible également. Grâce à la deuxième vue "Most recieving" il est possible de découvrir quels sont les domaines - trackers potentiels - qui sont fréquemment contactés par d'autres pages web. Chaque vue donne donc un point de vue différent sur le flux des données lorsque l'utilisateur parcourt le web.

		\begin{wrapfigure}{r}{3cm}
			\includegraphics[width=2cm]{images/design/pages/trackers_button}
			\caption{Domaine activé, puis désactivé}\label{d-buttons}
		\end{wrapfigure} 

		De plus, ces deux vues peuvent interagir : Il est possible de décider de cacher certains domaines de l'une ou de l'autre vue, car par exemple l'utilisateur souhaiterait ne pas prendre en compte les données d'un certain site web, ou à l'inverse ignorer les données envoyées vers un potentiel tracker particulier.\\
		Un bouton permettant d'activer ou de désactiver les données du domaine est présent à chaque ligne, et la désactivation de celui-ci impacte la vue des données de l'ensemble des deux pages "Trackers". La figure~\ref{d-buttons} montre un bouton de domaine activé et désactivé.
		
		Ainsi il est par exemple possible de désactiver les données émises par un domaine, et de regarder quelle est la répercussion sur les données reçues par les autres.

		La figure~\ref{trackers_images} montre la différence entre la vue imaginée et le résultat final d'une des deux pages Trackers. La figure~\ref{tracker_images} montre la différence entre la vue imaginée et le résultat final de la page détaillée d'un tracker.

		\begin{figure}[p]
			\centering
			\subfloat[Maquette initiale de la vue]{\includegraphics[width=0.3\textwidth,valign=t]{images/design/pages/trackers_mockup}}
			\subfloat[Exemple de résultat final]{\includegraphics[width=0.75\textwidth,valign=t]{images/design/pages/trackers_final}}
			\caption{Maquette initiale et résultat final d'une des vues Trackers}
			\label{trackers_images}
		\end{figure}

		\begin{figure}[p]
			\centering
			\subfloat[Maquette initiale de la vue]{\includegraphics[width=0.6\textwidth,valign=t]{images/design/pages/tracker_mockup}}

			\subfloat[Exemple de résultat final]{\includegraphics[width=0.75\textwidth,valign=t]{images/design/pages/tracker_final}}
			\caption{Maquette initiale et résultat final de la vue détaillée lors d'un clic sur un Tracker}
			\label{tracker_images}
		\end{figure}

		De plus, il est possible sur chacune des deux pages d'accéder aux statistiques détaillées sur le trafic de données d'un domaine particulier. En cliquant sur un domaine, l'interface ouvre une troisième vue qui montre en détail le nombre de requêtes liées à un domaine particulier.

	\newpage

	\subsection{Données}

		Une seule source de données est nécessaire à constituer cette visualisation :
		\begin{description}
			\item[Requêtes pré-calculées] : Nombre de requêtes entre chahque domaine. Ces données sont stockées dans la table \texttt{precalc\_trackers} (figure \ref{table-precalc-trackers}).
		\end{description}

		\FloatBarrier

	\subsection{Traitement}

		Peu de traitements entrent en jue dans la génération de la page Trackers. Il s'agit principalement de calculer la somme d'une liste de domaines. Ceci est illustré par la figure~\ref{trackers_algo} :
		\begin{description}
			\item[A] On additionne le nombre de requêtes faite pour un domaine vers un autre domaine, et on enregistre le total pour chaque paire par utilisateur. Toutes ces données sont pré-calculées avant le lancement du serveur. Il s'agit de calculer le nombre de requêtes de chaque domaine vers chaque autre domaine pour chaque utilisateur. La nécessité de pré-calculer ces données vient de leur quantité brute. Les compter sur le moment pour chaque requête demande trop de temps.

			\item[B] L'endpoint \texttt{/api/getTrackers} sert l'ensemble des résultats enregistrés pour l'utilisateur.

			\item[C] On cherche ici les domaines ayant reçu le plus de requêtes. Nous allons donc effectuer regrouper les requêtes faites par leur nom de domaine de destination, et effectuer la somme des autres mesures.

			\item[D] Inversément à l'étape précédente, on cherche cette fois les domaines ayant envoyé le plus de requêtes. Nous allons regrouper les requêtes par leur domaine d'envoie, et effectuer la somme des autres mesures.

			\item[E] Les deux listes obtenues aux étapes précédentes sont alors affichées dans leur page correspondante.

			\item[F] L'utilisateur peut choisir de cacher ou d'afficher un certain domaine d'une des vues. Ceci lance alors un nouveau calcul à partir de l'étape C. Aucune communication avec le serveur n'est nécessaire : Les données reçues initialement sont préservées.

			\item[G] L'utilisateur peut également choisir d'afficher les requêtes d'un domaine particulier.

			\item[H] Dans le cas de la sélection d'un domaine à afficher en détail, la liste des requêtes est filtrée est l'interface n'affiche que les requêtes concernant le domaine souhaité.
		\end{description}

		\begin{figure}[!h]
			\centering
			\includegraphics[height=0.95\textwidth]{images/design/pages/trackers_algo}
			\caption{Algorithme utilisé pour les données des pages "Trackers"}
			\label{trackers_algo}
		\end{figure}

	\subsection{Visualisation}

		Les deux listes sont des tableaux HTML stylisés par Bootstrap. La gestion de leur interaction et de leur affichage est géré par plusieurs composants Vue imbriqués.

\clearpage

%
%
% STATS
%
%

\section{Stats}

	\subsection{Concept}

		Le but de la vue Stats est de résumer très rapidement en quelques nombres la quantité de données échangées entre les différents domaines visités par l'utilisateur.

		\begin{figure}[!h]
			\centering
			\subfloat[Maquette initiale de la vue]{\includegraphics[width=0.3\textwidth,valign=t]{images/design/pages/stats_mockup}}
			\subfloat[Exemple de résultat final]{\includegraphics[width=0.7\textwidth,valign=t]{images/design/pages/stats_final}}
			\caption{Maquette initiale et résultat final d'une vue Stats}
			\label{stats_images}
		\end{figure}

	\subsection{Données}

		Une seule source de données est nécessaire à constituer cette visualisation :
		\begin{description}
			\item[Requêtes pré-calculées] : Nombre de requêtes entre chahque domaine. Ces données sont stockées dans la table \texttt{precalc\_trackers} (figure \ref{table-precalc-trackers}).
		\end{description}

	\subsection{Traitement}

		Très peu de traitements sont nécessaires pour cette vue. La figure~\ref{stats_algo} montre le traitement effectué aux données avant de les afficher.

		Les données nécessaires à cette vue sont calculées en temps réel : Il s'agit simplement de compter le nombre de requêtes enregistrées dans la table pré-calculée, ainsi que le nombre unique de nom de domaines.

		\begin{description}
			\item[A] On additionne le nombre de requêtes faite pour un domaine vers un autre domaine, et on enregistre le total pour chaque paire par utilisateur. Toutes ces données sont pré-calculées avant le lancement du serveur. Il s'agit de calculer le nombre de requêtes de chaque domaine vers chaque autre domaine pour chaque utilisateur. La nécessité de pré-calculer ces données vient de leur quantité brute. Les compter sur le moment pour chaque requête demande trop de temps.

			\item[B] On calcule le total de certaines valeurs pour les requêtes de l'utilisateur : Par exemple, le nombre total effectuées, et le nombre total de domaines différents.

			\item[C] On calcule ici certaines valeurs globales pour l'ensemble des utilisateurs. Par exemple le nombre total effectuées, et le nombre total de domaines différents.

			\item[D et E] On affiche les nombres résultats des opérations précédente dans leur page respective, à savoir "Your stats" présentant les statistiques de l'utilisateur uniquement, ou "Global stats" affichant les statistiques globales sur la base de données.

		\end{description}

		\begin{figure}[!h]
			\centering
			\includegraphics[height=0.6\textwidth]{images/design/pages/stats_algo}
			\caption{Algorithme utilisé sur les données de la page "Stats"}
			\label{stats_algo}
		\end{figure}

	\subsection{Visualisation}

		Les nombres renvoyées par le serveur sont simplement affichés dans des \texttt{card}s de Bootstrap.

\clearpage

%
%
% SETTINGS
%
%

\section{Settings}

	\subsection{Concept}

		Le but de la page Settings est de montrer à l'utilisateur la possibilité de renseigner ces centres d'intérêt. Ces informations nous seront utiles par la suite pour tenter d'associer les centres d'intérêt entrés ici avec les topics que nous estimons être importants.

		La figure~\ref{settings_image} montre un formulaire à remplir par l'utilisateur. Celui-ci cherche ces centres d'intérêts parmi une liste de 101, organisés hiérarchiquement. Un maximum de 10 centres d'intérêts peuvent être choisis.

		\begin{figure}[!h]
			\centering
			\includegraphics[height=0.32\textwidth]{images/design/pages/settings}
			\caption{Champ d'entrée des centres d'intérêts}
			\label{settings_image}
		\end{figure}

		Une fois que l'utilisateur a défini des centres d'intérêt, il peut donner des informations sur la page Topics (voir section \ref{topicslist}). Les centres d'intérêts choisis sur la page Settings sont donc "simplement" utilisés pour définir quels seront les choix de centres d'intérets possibles sur la page Topics List. La figure~\ref{choice} montre la fenêtre déroulante de sélection d'un centre d'intérêt pour un topic donné.

		\begin{figure}[!h]
			\centering
			\includegraphics[height=0.32\textwidth]{images/results/choice}
			\caption{Sélection d'intérêt sur un topic}
			\label{choice}
		\end{figure}

		Il est demandé aux utilisateurs d'ajouter une association entre un topic et un intérêt lorsque cela semble lui faire sens. Ainsi, nous pouvons savoir quels topics de l'utilisateur nous avons réussi à identifier. En effet, lorsqu'un utilisateur associe un centre d'intérêt à un topic, celà signifie non seulement que le topic trouvé a du sens en soi, mais en plus qu'il est intéressant pour l'utilisateur.

	\subsection{Données}

		Deux source de données est nécessaire à constituer la vue Settings :
		\begin{description}
			\item[Liste des 101 centres d'intérêts] : Ces données sont stockées dans la table \texttt{interests} (figure \ref{table-interests}).
			\item[Centres d'intérêt de l'utilisateur] : Ces données sont stockées dans la table \texttt{user\_interests} (figure \ref{table-user-interests}).
		\end{description}

	\subsection{Traitement}

		Très peu de traitements sont nécessaires pour cette vue. La plupart des données nécessaires à cette vue sont calculées en temps réel : Il s'agit simplement de compter le nombre de requêtes enregistrées dans la table pré-calculée, ainsi que le nombre unique de nom de domaines.

		La figure~\ref{stats_algo} montre le traitement effectué aux données avant de les afficher.

		\begin{description}
			\item[A] La liste pré-définie de centres d'intérêts est ajoutée à la base de données. Cette opération n'est à effectuer qu'une seule fois, le but de cette liste n'est pas de changer. Dans notre cas, la liste des centres d'intérêts provient de ceux utilisés par la classification des utilisateurs par Google.

			\item[B] On envoie la liste des centres d'intérêts et de leur nom au client

			\item[C] On envoie également la liste des centres d'intérets que l'utilisateur a déjà renseignés, afin de les afficher directement comme étant entrés dans le formulaire.

			\item[E] L'utilisateur peut donc changer ses centres d'intérêts, puis envoyer sa nouvelle liste au serveur.

			\item[F] Les nouveaux centres d'intérêts sont donc enregistrés, et la nouvelle liste est envoyée une fois supplémentaire cu lient, reprenant au point C de l'algorithme.

		\end{description}

		\begin{figure}[!h]
			\centering
			\includegraphics[height=0.55\textwidth]{images/design/pages/settings_algo}
			\caption{Algorithme utilisé pour les données de la page "Settings"}
			\label{settings_algo}
		\end{figure}

	\subsection{Visualisation}

		Le champ du formulaire permettant d'entrer des centres d'intérêts en affichant leur hiérarchisation est une instance configurée de la librairie JavaScript nommée Selectize\cite{selectize}, dont le but est de proposer des champs de formulaire personnalisés tels que celui-ci.

\clearpage